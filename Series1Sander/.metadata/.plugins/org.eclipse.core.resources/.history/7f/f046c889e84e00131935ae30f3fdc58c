module Main

import lang::java::m3::Core;
import lang::java::m3::AST;
import lang::java::jdt::m3::Core;
//import lang::java::jdt::m3::AST;
import lang::java::\syntax::Java15;
//import lang::java::\syntax::Disambiguate;
import List;
import Exception;
import ParseTree;
import IO;
import Set;
import util::FileSystem;

loc MY_PROJECT = |project://HelloWorld|;

public void main() {
  myModel = getM3FromProject(getProject());			
  //println("myModel: <myModel>");
  
  myMethods = toList(methods(myModel));
  //println("myMethods: <myMethods>");
  
  i = 1; // take second method
  
  methodAST = getMethodAST(myMethods[i]);
  println("methodAST: <methodAST>");
  
  
  methodAST2 = getMethodASTEclipse(myMethods[i]);
  
  CC = calcCC(methodAST);
  println("CC: <CC>");
  
  println("method: <readFile(myMethods[i])>");
  
  /*
  complexFiles = findComplexFiles(getProject());
  println("complexFiles: <complexFiles>");
  
  myMethods = [getMethods(q) | q <- getFiles(getProject())];
  println("myMethods: <myMethods>");
  */
}


/*
	utility methods
*/
loc getProject() {
  return MY_PROJECT;
}

M3 getM3FromProject(loc project) {
  return createM3FromEclipseProject(project);
}

list[loc] getFiles(loc project) {
  result = [f | /file(f) <- crawl(project), f.extension == "java"];
  return result;	
}

set[MethodDec] getMethods(loc file) {
  result = {m | /MethodDec m := parse(#start[CompilationUnit], file)};
  return result;
}


/*
	calculate CC (based on type Declaration)
*/
int calcCC(Declaration m) {
  result = 1;
  visit (m) {
  	case /Statement (_): {
  		println("found");
  		result += 1;
  	}
  }
  return result;
}


/*
	calculate CC from http://www.rascal-mpl.org/#_Metrics
*/
int cyclomaticComplexity(MethodDec m) {
  result = 1;
  visit (m) {
    case (Stm)`do <Stm _> while (<Expr _>);`: result += 1;
    case (Stm)`while (<Expr _>) <Stm _>`: result += 1;
    case (Stm)`if (<Expr _>) <Stm _>`: result +=1;
    case (Stm)`if (<Expr _>) <Stm _> else <Stm _>`: result +=1;
    case (Stm)`for (<{Expr ","}* _>; <Expr? _>; <{Expr ","}*_>) <Stm _>` : result += 1;
    case (Stm)`for (<LocalVarDec _> ; <Expr? e> ; <{Expr ","}* _>) <Stm _>`: result += 1;
    case (Stm)`for (<FormalParam _> : <Expr _>) <Stm _>` : result += 1;
    case (Stm)`switch (<Expr _> ) <SwitchBlock _>`: result += 1;
    case (SwitchLabel)`case <Expr _> :` : result += 1;
    case (CatchClause)`catch (<FormalParam _>) <Block _>` : result += 1;
  }
  return result;
}


lrel[int cc, loc method] findComplexFiles(loc project) {
  result = [*maxCC(f) | /file(f) <- crawl(project), f.extension == "java"];	
  result = sort(result, bool (<int a, loc _>, <int b, loc _>) { return a < b; });
  // return head(reverse(result), limit);
  return result;
}

set[MethodDec] allMethods(loc file) 
  = {m | /MethodDec m := parse(#start[CompilationUnit], file)};

lrel[int cc, loc method] maxCC(loc file) 
  = [<cyclomaticComplexity(m), m@\loc> | m <- allMethods(file)];
